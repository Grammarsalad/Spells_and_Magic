
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////                    Update Tooltips                     //////////////////////////
//////////////////////////                    Credit:                             //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

// This action function handles updating of tooltips - entries in the TOOLTIP.2DA table.
/*
LAF tooltips INT_VAR
  $tip(1) = 0 - 1 // set the 1st ability's tooltip to -1, in which case the engine will display ITM's name instead
  $tip(2) = 6618 // set the 2nd ability's tooltip to #6618, which is ~Fireball~ in original game
  $tip(4) = RESOLVE_STR_REF (@1234) // set the 4th ability's tooltip to @1234, which you must have defined in .TRA file
STR_VAR
  item = sw1h01 // do the above for SW1H01.ITM
END
*/
// You can also substitute variables for the header's index:
/*
OUTER_SET sample_var = 3
LAF tooltips INT_VAR
  $ EVAL tip("%sample_var%") = 0 - 1 // set the "%sample_var%"th tooltip to -1, in this case it is the 3rd one
STR_VAR
  item = sw1h01
END
*/
// Finally, instead of overwriting existing tooltips, you can insert new ones between them. This is useful when you
// have added new ability header not as the last, but before any of already existing ones AND you do not know for
// sure if that item already had any tooltips, and if it did - how many and which exactly.
// This is how we'd add the "Shield Bash" ability to Anomen's shield - which must go first in order for the
// ~UseItemSlot()~ script action to use the Bash on the target, not the Protection from Missiles
/*
LAF tooltips INT_VAR
  $insert(1) = RESOLVE_STR_REF (~Shield Bash~)
STR_VAR
  item = npshld
END
*/
// You can set both $tip() and $insert() in one launch, in this case old tooltips will be first overwritten with
// the $tip() array, then new insertions will be made.
//
//
// On a side note, adding new headers, especially when not as last in the order, will break charge amounts in ARE,
// CRE and STO files, in saved games, in ~GiveItemCreate()~ and ~CreateItem()~ script actions. Don't insert anything
// unless you !!!REALLY!!! know what you are doing.


DEFINE_ACTION_FUNCTION tooltips STR_VAR item=~ag#dummy~ BEGIN

COPY_EXISTING tooltip.2da override

  // find the item entry
  COUNT_2DA_COLS cn
  READ_2DA_ENTRIES_NOW rn cn
  row= 0 - 1
  FOR (k=0;k<rn;k+=1) BEGIN
    READ_2DA_ENTRY_FORMER rn k 0 itm
    PATCH_IF ~%item%~ STRING_EQUAL_CASE ~%itm%~ BEGIN
      FOR (i=1;i<cn;i+=1) BEGIN
        READ_2DA_ENTRY_FORMER rn k i x
        SET $ EVAL rn("%i%") = x
      END
      row=k
      k=rn
    END
  END

  // if it doesn't exist, add new one
  PATCH_IF row<0 BEGIN
    row=rn
    SPRINT add ~~
    FOR (i=1;i<cn;i+=1) BEGIN
      SPRINT add ~%add%        -1~
    END
    INSERT_2DA_ROW rn cn ~%item%%add%~
  END

  // preset entries, check if there're enough columns
  d=0
  PHP_EACH tip AS i => r BEGIN
    SET $ EVAL rn("%i%") = r
    i+=1
    PATCH_IF cn<i BEGIN
      d += i - cn
      cn=i
    END
  END

  // insert strrefs, check if there're enough columns
  hc=0
  PATCH_IF FILE_EXISTS_IN_GAME ~%item%.itm~ BEGIN
    INNER_PATCH_FILE ~%item%.itm~ BEGIN
      READ_SHORT 0x68 hc
    END
  END
  PHP_EACH insert AS i => r BEGIN
    SET_2DA_ENTRY_LATER sl row i ~%r%~
    PATCH_IF hc > cn - 1 BEGIN // no point in shifting columns if there are not that many headers
      d+=1
      cn+=1
    END
    i+=1
    PATCH_IF cn<i BEGIN
      d += i - cn
      cn=i
    END
  END

  // if there're not enough columns, extend the 2da
  PATCH_IF d BEGIN
    SPRINT add ~~
    FOR (i=cn - d;i<cn;i+=1) BEGIN
      SPRINT add ~%add%        -1~
    END
    cnt=0
    REPLACE_EVALUATE ~\(.+\)~ BEGIN
      SPRINT nl ~~
      INNER_PATCH_SAVE ~MATCH1~ ~%MATCH1%~ BEGIN
        REPLACE_EVALUATE ~\([%LNL%%MNL%%WNL%]\)~ BEGIN
          SPRINT nl ~%MATCH1%~
        END ~~
      END
      cnt+=1
      PATCH_IF cnt>3 BEGIN
        SPRINT ~MATCH1~ ~%MATCH1%        %add%~
      END
      PATCH_IF cnt=3 BEGIN
        FOR (i=cn - d;i<cn;i+=1) BEGIN
          SPRINT ~MATCH1~ ~%MATCH1%        %i%~
        END
      END
    END ~%MATCH1%%nl%~
  END

  // shift entries if something was inserted in the midst
  PHP_EACH rn AS i => r BEGIN
    PHP_EACH insert AS i2 => r2 BEGIN
      PATCH_IF i2<=i BEGIN
        i+=1
      END
    END
    SET_2DA_ENTRY_LATER sl row i ~%r%~
  END


  SET_2DA_ENTRIES_NOW sl cn
  PRETTY_PRINT_2DA
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////                    Make Creature Illusory              //////////////////////////
//////////////////////////                    Credit: Angel                       //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION make_illusion
  INT_VAR   power_level   = "-1"
BEGIN
  WRITE_LONG 0x0010 THIS | BIT1      // No corpse
  WRITE_LONG 0x0014 0                // XP
  WRITE_LONG 0x001c 0                // Gold
  WRITE_BYTE 0x0270 IDS_OF_SYMBOL("ea" "neutral")
  WRITE_BYTE 0x0275 IDS_OF_SYMBOL("gender" "illusionary")

  // Add unstealable&undroppable flags to carried items
  GET_OFFSET_ARRAY itm_array CRE_V10_ITEMS
  PHP_EACH itm_array AS int => itm_offset
  BEGIN
    WRITE_LONG (itm_offset + 0x0010) (THIS | (BIT1 | BIT3))
  END

  // Handle power level if specified
  PATCH_IF (power_level >= 0)
  BEGIN
    WRITE_LONG  0x0018 power_level
  END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////                       Make Cantrip                     //////////////////////////
//////////////////////////                                                        //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION MAKE_CANTRIP
  INT_VAR   type            = "0" // 0 = Innate, Spell menu, no failure, infinite casting
//                                // 1 = Innate, innate menu, no failure, infinite casting
//                          //TO DO: 3 = Mage/Priest Level 1, innate menu, no failure, infinite casting
//                          //TO DO: 4 = Mage/Priest Level 1, spell menu, no failure, infinite casting
  STR_VAR   level_text      = "Cantrip"  //Infinite cast: File name of spl (Really should be the spl in question, though exceptions are possible)
            spell_name      = "SAME"  //Spell name if not original

  BEGIN
  READ_LONG  0x64 abil_off ELSE 0
  READ_SHORT 0x68 abil_num ELSE 0

////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////type zero (0)
////////////////////////////////////////////////////////////////////////////////////////

PATCH_IF (type = 0) BEGIN //Type: 0: Innate spell but spell menu
//spell type
  WRITE_SHORT 0x1C 4                         // sets spell type to innate (4)
//level
  WRITE_LONG  0x34 1                         // sets spell level to 1 to avoid scripting issues
//location
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    WRITE_SHORT (abil_off + 0x02 + (0x28 * index)) 2 //spell location: spell menu
  END
//no failure
   WRITE_LONG 0x0018 (THIS | 0x4000)       //No failure


//infinite casting
     PATCH_IF ("%spell_name%" STRING_COMPARE_CASE "SAME" != 0) BEGIN //
	PATCH_IF (~%SOURCE_SIZE%~ > ~0x71~) BEGIN
        READ_LONG 	0x64	ab_off			// Abilities Offset
	READ_SHORT	0x68	ab_num			// Number of Abilities
	READ_SHORT	0x6a	fx_off			// Effects Offset
	READ_SHORT	0x70	glob_fx			// Number of Global Effects
	SET	glob_add = 0

	INSERT_BYTES (fx_off) 0x30
	  WRITE_SHORT (fx_off) 171			// Give innate
	  WRITE_BYTE (fx_off + 0x2) 1			// Target Self
	  WRITE_BYTE (fx_off + 0x3) 1			// power
	  WRITE_LONG (fx_off + 0x8) 0			// Wizard
	  WRITE_LONG (fx_off + 0xc) 9			// perm
	  WRITE_BYTE (fx_off + 0x12) 100		// Probability 1
	  WRITE_ASCIIE (fx_off + 0x14) 	"%spell_name%"  // resource
	++glob_add

        INSERT_BYTES (fx_off) 0x30
	  WRITE_SHORT (fx_off) 172			// Remove spell
	  WRITE_BYTE (fx_off + 0x2) 1			// Target Self
	  WRITE_BYTE (fx_off + 0x3) 1			// power
	  WRITE_LONG (fx_off + 0x8) 0			// Wizard
	  WRITE_LONG (fx_off + 0xc) 9			// perm
	  WRITE_BYTE (fx_off + 0x12) 100		// Probability 1
	  WRITE_ASCIIE (fx_off + 0x14) "%spell_name%"	// resource
	++glob_add

//	INSERT_BYTES (fx_off) 0x30			//Second effect
//	  WRITE_etc...
//	++glob_add

	glob_fx += glob_add
	WRITE_SHORT 0x70 glob_fx			// Increment Number of Global Effects
	FOR (i = 0; i < ab_num; ++i) BEGIN		// Offset Effect Index for all Abilities
	  READ_SHORT (ab_off + i * 0x28 + 0x20) fx_idx
	  WRITE_SHORT (ab_off + i * 0x28 + 0x20) (fx_idx + glob_add)
	END
     END
     END ELSE //end of infinite casting without specification
     BEGIN
	PATCH_IF (~%SOURCE_SIZE%~ > ~0x71~) BEGIN
        READ_LONG 	0x64	ab_off			// Abilities Offset
	READ_SHORT	0x68	ab_num			// Number of Abilities
	READ_SHORT	0x6a	fx_off			// Effects Offset
	READ_SHORT	0x70	glob_fx			// Number of Global Effects
	SET	glob_add = 0

	INSERT_BYTES (fx_off) 0x30
	  WRITE_SHORT (fx_off) 171			// Give innate
	  WRITE_BYTE (fx_off + 0x2) 1			// Target Self
	  WRITE_BYTE (fx_off + 0x3) 1			// power
	  WRITE_LONG (fx_off + 0x8) 0			// Wizard
	  WRITE_LONG (fx_off + 0xc) 9			// perm
	  WRITE_BYTE (fx_off + 0x12) 100		// Probability 1
	  WRITE_ASCIIE (fx_off + 0x14) "%SOURCE_RES%"	// resource
	++glob_add

        INSERT_BYTES (fx_off) 0x30
	  WRITE_SHORT (fx_off) 172			// Remove spell
	  WRITE_BYTE (fx_off + 0x2) 1			// Target Self
	  WRITE_BYTE (fx_off + 0x3) 1			// power
	  WRITE_LONG (fx_off + 0x8) 0			// Wizard
	  WRITE_LONG (fx_off + 0xc) 9			// perm
	  WRITE_BYTE (fx_off + 0x12) 100		// Probability 1
	  WRITE_ASCIIE (fx_off + 0x14) "%SOURCE_RES%"	// resource
	++glob_add

//	INSERT_BYTES (fx_off) 0x30			//Second effect
//	  WRITE_etc...
//	++glob_add

	glob_fx += glob_add
	WRITE_SHORT 0x70 glob_fx			// Increment Number of Global Effects
	FOR (i = 0; i < ab_num; ++i) BEGIN		// Offset Effect Index for all Abilities
	  READ_SHORT (ab_off + i * 0x28 + 0x20) fx_idx
	  WRITE_SHORT (ab_off + i * 0x28 + 0x20) (fx_idx + glob_add)
	END
      END
     END

  READ_LONG 0x50 "valid"
  PATCH_IF ("%level_text%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN
	REPLACE_TEXTUALLY ~Level: Cantrip~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: Orison~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 1~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 2~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 3~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 4~ ~Level: %level_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~Level: 5~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 6~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 7~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 8~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 9~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 10~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: Quest~ ~Level: %level_text%~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~
  END  //
  END
END //end type 0

////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////type one (1)
////////////////////////////////////////////////////////////////////////////////////////
PATCH_IF (type = 1) BEGIN //Type: 1: Innate spell and menu
//spell type
  WRITE_SHORT 0x1C 4                         // sets spell type to innate (4)
//level
  WRITE_LONG  0x34 1                         // sets spell level to 1 to avoid scripting issues
//location
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    WRITE_SHORT (abil_off + 0x02 + (0x28 * index)) 4 //spell location: innate menu
  END
//no failure
   WRITE_LONG 0x0018 (THIS | 0x4000)       //No failure


//infinite casting
     PATCH_IF ("%spell_name%" STRING_COMPARE_CASE "SAME" != 0) BEGIN //
	PATCH_IF (~%SOURCE_SIZE%~ > ~0x71~) BEGIN
        READ_LONG 	0x64	ab_off			// Abilities Offset
	READ_SHORT	0x68	ab_num			// Number of Abilities
	READ_SHORT	0x6a	fx_off			// Effects Offset
	READ_SHORT	0x70	glob_fx			// Number of Global Effects
	SET	glob_add = 0

	INSERT_BYTES (fx_off) 0x30
	  WRITE_SHORT (fx_off) 171			// Give innate
	  WRITE_BYTE (fx_off + 0x2) 1			// Target Self
	  WRITE_BYTE (fx_off + 0x3) 1			// power
	  WRITE_LONG (fx_off + 0x8) 0			// Wizard
	  WRITE_LONG (fx_off + 0xc) 9			// perm
	  WRITE_BYTE (fx_off + 0x12) 100		// Probability 1
	  WRITE_ASCIIE (fx_off + 0x14) 	"%spell_name%"  // resource
	++glob_add

        INSERT_BYTES (fx_off) 0x30
	  WRITE_SHORT (fx_off) 172			// Remove spell
	  WRITE_BYTE (fx_off + 0x2) 1			// Target Self
	  WRITE_BYTE (fx_off + 0x3) 1			// power
	  WRITE_LONG (fx_off + 0x8) 0			// Wizard
	  WRITE_LONG (fx_off + 0xc) 9			// perm
	  WRITE_BYTE (fx_off + 0x12) 100		// Probability 1
	  WRITE_ASCIIE (fx_off + 0x14) "%spell_name%"	// resource
	++glob_add

//	INSERT_BYTES (fx_off) 0x30			//Second effect
//	  WRITE_etc...
//	++glob_add

	glob_fx += glob_add
	WRITE_SHORT 0x70 glob_fx			// Increment Number of Global Effects
	FOR (i = 0; i < ab_num; ++i) BEGIN		// Offset Effect Index for all Abilities
	  READ_SHORT (ab_off + i * 0x28 + 0x20) fx_idx
	  WRITE_SHORT (ab_off + i * 0x28 + 0x20) (fx_idx + glob_add)
	END
     END
     END ELSE //end of infinite casting without specification
     BEGIN
	PATCH_IF (~%SOURCE_SIZE%~ > ~0x71~) BEGIN
        READ_LONG 	0x64	ab_off			// Abilities Offset
	READ_SHORT	0x68	ab_num			// Number of Abilities
	READ_SHORT	0x6a	fx_off			// Effects Offset
	READ_SHORT	0x70	glob_fx			// Number of Global Effects
	SET	glob_add = 0

	INSERT_BYTES (fx_off) 0x30
	  WRITE_SHORT (fx_off) 171			// Give innate
	  WRITE_BYTE (fx_off + 0x2) 1			// Target Self
	  WRITE_BYTE (fx_off + 0x3) 1			// power
	  WRITE_LONG (fx_off + 0x8) 0			// Wizard
	  WRITE_LONG (fx_off + 0xc) 9			// perm
	  WRITE_BYTE (fx_off + 0x12) 100		// Probability 1
	  WRITE_ASCIIE (fx_off + 0x14) "%SOURCE_RES%"	// resource
	++glob_add

        INSERT_BYTES (fx_off) 0x30
	  WRITE_SHORT (fx_off) 172			// Remove spell
	  WRITE_BYTE (fx_off + 0x2) 1			// Target Self
	  WRITE_BYTE (fx_off + 0x3) 1			// power
	  WRITE_LONG (fx_off + 0x8) 0			// Wizard
	  WRITE_LONG (fx_off + 0xc) 9			// perm
	  WRITE_BYTE (fx_off + 0x12) 100		// Probability 1
	  WRITE_ASCIIE (fx_off + 0x14) "%SOURCE_RES%"	// resource
	++glob_add

//	INSERT_BYTES (fx_off) 0x30			//Second effect
//	  WRITE_etc...
//	++glob_add

	glob_fx += glob_add
	WRITE_SHORT 0x70 glob_fx			// Increment Number of Global Effects
	FOR (i = 0; i < ab_num; ++i) BEGIN		// Offset Effect Index for all Abilities
	  READ_SHORT (ab_off + i * 0x28 + 0x20) fx_idx
	  WRITE_SHORT (ab_off + i * 0x28 + 0x20) (fx_idx + glob_add)
	END
      END
     END

  READ_LONG 0x50 "valid"
  PATCH_IF ("%level_text%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN
	REPLACE_TEXTUALLY ~Level: Cantrip~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: Orison~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 1~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 2~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 3~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 4~ ~Level: %level_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~Level: 5~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 6~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 7~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 8~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 9~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 10~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: Quest~ ~Level: %level_text%~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~
  END  //
  END

END //end type 1

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////                     Alter Effect Add                   //////////////////////////
//////////////////////////                                                        //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

//ALTER EFFECT MACRO_________________________________________________________________
//
DEFINE_PATCH_FUNCTION ALTER_EFFECT_ADD
  // defines what we're going to check
  INT_VAR check_globals       = 1      
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          debug               = 0
  // variables for finding the effect to match
          match_opcode        = "-1"   
          match_target        = "-1"   
          match_power         = "-1"   
          match_parameter1    = "-1"   
          match_parameter2    = "-1"   
          match_timing        = "-1"   
          match_resist_dispel = "-1"   
          match_duration      = "-1"
          match_duration_high = "-1"   
          match_probability1  = "-1"   
          match_probability2  = "-1"   
          match_dicenumber    = "-1"   
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"
  // variables for the new effect
          opcode              = "-1"   
          target              = "-1"   
          power_add           = "-1"   
          parameter1          = "-1"   
          parameter2          = "-1"
          timing              = "-1"   
          resist_dispel       = "-1"   
          duration_add        = "-1"   
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"   
          dicenumber_add      = "-1"   
          dicesize_add        = "-1"
          savingthrow         = "-1"
          savebonus_add       = "-11"
          special_add             = "-1"
  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"
BEGIN
  // set variables and offsets based on the file type
  SET alter = 0
  PATCH_IF ("%SOURCE_FILE%" STRING_COMPARE_REGEXP "^.+\.spl" = 0) BEGIN
    READ_LONG   0x6a fx_off   ELSE 0
    SET counter_offset = 0x70
    SET abil_length    = 0x28
    SET fx_type        = 0
    SET min_size       = 0x72
    PATCH_IF (check_headers = 0) BEGIN
      SET abil_num = 0
    END ELSE BEGIN
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END
  END ELSE
  PATCH_IF ("%SOURCE_FILE%" STRING_COMPARE_REGEXP "^.+\.itm" = 0) BEGIN
    READ_LONG   0x6a fx_off   ELSE 0
    SET counter_offset = 0x70
    SET abil_length    = 0x38
    SET fx_type        = 0
    SET min_size       = 0x72
    PATCH_IF (check_headers = 0) BEGIN
      SET abil_num = 0
    END ELSE BEGIN
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END
  END ELSE
  PATCH_IF ("%SOURCE_FILE%" STRING_COMPARE_REGEXP "^.+\.cre" = 0) BEGIN // creature effects treated like they're a single, global loop
    SET abil_off = 0 // basically prevents the ability effect loop
    SET abil_num = 0
    READ_LONG  0x2c4 fx_off ELSE 0
    SET counter_offset = 0x2c8
    SET abil_length = 0
    READ_BYTE 0x33 fx_type ELSE 2
    SET min_size = 0x2d4
    SET check_globals = 1
  END ELSE BEGIN
    SET min_size = "-1" // kill macro as the file type is not recognized
  END
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0))) BEGIN                               // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN
          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special
          // match ALL these variables, if specified
          PATCH_IF (((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)   OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN
            // lazily re-use code
            SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))
            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power_add >= 0)     BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) (power_add + o_power) END
            PATCH_IF (parameter1 >= 0)    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 >= 0)    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (special_add >= 0)   BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) (duration_add + o_duration) END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber_add >= 0) BEGIN WRITE_LONG (base + 0x1c + (0x14 * fx_type)) (dicenumber_add + o_dicenumber) END
            PATCH_IF (dicesize_add >= 0)  BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) (dicesize_add + o_dicesize) END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus_add >= "-10") BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) (savebonus_add + o_savebonus) END
            PATCH_IF (special_add >= 0)   BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) (special_add + o_special) END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END
            // update the tracking vars
            SET alter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END
          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
    END // end loop through effects on ability
  END // end ability loop
  // spit out some info if debug is set
  PATCH_IF (debug = 1) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_IF (alter = 0) BEGIN
      PATCH_PRINT "  Warning: No effects altered on %SOURCE_FILE% (%name%)"
    END ELSE BEGIN
      PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered"
    END
  END
END
//__________________________________________________________________________________

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////                    Alter Spell Type                    //////////////////////////
//////////////////////////                                                        //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION ALTER_SPELL_TYPE
  INT_VAR   spell_type        = "-1" //Special: (0); Wizard: (1); Cleric: (2); Psionic: (3); Innate: (4); Song: (5)
            spell_level       = "-1"
            location          = "-1" //none: (0); spell: (2); innate (4)
            school	      = "-1" //school: 0 = None; 1 = abjuration; 2 = conjuration; 3= divination; 4 = enchantment; 5 = illusion; 6 = invoker; 7 = necromancer; 8 = transmuter; 9 = trueclass mage; 10 = wild mage only
            opposition_school = "-1" //opposition school: 0 = None; 1 = abjuration; 2 = conjuration; 3= divination; 4 = enchantment; 5 = illusion; 6 = invoker; 7 = necromancer; 8 = transmuter; 9 = trueclass mage; 10 = wild mage only
         prohibited_alignment = "-1" //or prohibited alignment: 1 = exclude chaotic; 2 = evil; 3 = good; 4 = ethical neutral; 5 = lawful 6 = moral neutral
            casting_graphics  = "-1" //school: 0 = None; 1 = abjuration; 2 = conjuration; 3= divination; 4 = enchantment; 5 = illusion; 6 = invoker; 7 = necromancer; 8 = transmuter; 9 = black sparks
            cleric_druid_only = "-1" //0 = no restrictions; 1 = cleric/Pal exclusive (priest spells); 2 = druid/Ran exclusive (priest spells); 3 = prohibit all
            wild_mage         = "-1" //0 = Wildmage restricted (wm can't cast); 1 = Wildmage can cast (mage spells)
            sec_type          = "-1" //0 = none; 1 = Spell Protection; 2 = Specific Protections; 3 = Illusonary Protections; 4 = Magic Attack; 5 = Divination Attack; 6 = Conjuration; 7 = Combat Protections; 8 = Contingency; 9 = Battleground; 10 = Offensive Damage; 11 = Disabling; 12 = Combination; 13 = Non-Combat; 14 = Dorn's Sword
            failure           = "-1" // 0 = Failure NOT possible; 1 = Failure possible (other values not accepted)
            indoors           = "-1" // 0 = cannot be cast indoors; 1 = can cast indoors (other values not accepted)
            surge             = "-1" // 0 = wildsurge not possible; 1 = wildsurge possible (other values not accepted)
            los               = "-1" // 0 = Line of Sight required; 1 = no LOS required (other values not accepted)
            combat            = "-1" // 0 = cannot be cast in combat; 1 = CAN be cast in combat (other values not accepted)
            hostile           = "-1" // 0 = not hostile spell; 1 = Hostile (other values not accepted) !
            spotting          = "-1" // 0 = no spotting(?); 1 = spotting (other values not accepted)
            target_invisible  = "-1" // 0 = cannot target invisible; 1 = can target invisibile (other values not accepted)
            silence           = "-1" // 0 = cannot cast when silenced; 1 = can cast when silenced (other values not accepted)
  STR_VAR   level_text        = "SAME"  //Will replace level display with whatever is put in this field (whether an integer or text.)
   	    school_text	      = "SAME"  //Only necessary for user created schools
  	    sphere_text	      = "SAME"  //Name of sphere
	    c_icon            = "NO"  //"SAME" = %SOURCE_RES%C, "ADD" = %spell_res%C, else Exact name given of C icon

BEGIN
  READ_LONG  0x64 abil_off ELSE 0
  READ_SHORT 0x68 abil_num ELSE 0
  READ_ASCII (abil_off + 0x04) bam (8) // reads the bam filename from ability

// Handle spell_type if specified
PATCH_IF (spell_type >= 0) //types: innate(4)
  BEGIN
    WRITE_SHORT 0x1C spell_type
  PATCH_IF (location < 0) BEGIN
    PATCH_IF (spell_type = 0) OR ((spell_type = 2) OR (spell_type = 4)) BEGIN
      FOR (index = 0 ; index < abil_num ; ++index) BEGIN
        WRITE_SHORT (abil_off + 0x02 + (0x28 * index)) spell_type
      END
    END ELSE BEGIN
      FOR (index = 0 ; index < abil_num ; ++index) BEGIN
        WRITE_SHORT (abil_off + 0x02 + (0x28 * index)) 0
      END
    END
  END
END
  
  // Handle spell level if specified
PATCH_IF (spell_level > 0)
  BEGIN
    WRITE_LONG  0x34 spell_level
  END
// Handle location if specified
PATCH_IF (location >= 0) BEGIN
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    WRITE_SHORT (abil_off + 0x02 + (0x28 * index)) location
  END
END

// Handle opp school if specified (mage only)
PATCH_IF (opposition_school >= 0) BEGIN
  PATCH_IF (opposition_school = 0) BEGIN
   WRITE_LONG 0x001e 0x0000 //General spells, exclude nobody
  END
  PATCH_IF (opposition_school = 1) BEGIN
   WRITE_LONG 0x001e 0x0040 //General spells, exclude abjuration
  END
  PATCH_IF (opposition_school = 2) BEGIN
   WRITE_LONG 0x001e 0x0080 //General spells, exclude conjuration
  END
  PATCH_IF (opposition_school = 3) BEGIN
   WRITE_LONG 0x001e 0x0100 //General spells, exclude divination
  END
  PATCH_IF (opposition_school = 4) BEGIN
   WRITE_LONG 0x001e 0x0200 //General spells, exclude enchanter
  END
  PATCH_IF (opposition_school = 5) BEGIN
   WRITE_LONG 0x001e 0x0400 //General spells, exclude illusion
  END
  PATCH_IF (opposition_school = 6) BEGIN
   WRITE_LONG 0x001e 0x0800 //General spells, exclude invoker
  END
  PATCH_IF (opposition_school = 7) BEGIN
   WRITE_LONG 0x001e 0x1000 //General spells, exclude necro
  END
  PATCH_IF (opposition_school = 8) BEGIN
   WRITE_LONG 0x001e 0x2000 //General spells, exclude transmutation
  END
  PATCH_IF (opposition_school = 9) BEGIN
   WRITE_LONG 0x001e 0x4000 //General spells, exclude trueclass mage
  END
  PATCH_IF (opposition_school = 10) BEGIN
   WRITE_LONG 0x001e 0x7fc0 //General spells, wildmage only
  END
END
//prohibited_alignment if specified (priest only)
PATCH_IF (prohibited_alignment > 0) BEGIN
  PATCH_IF (prohibited_alignment = 1) BEGIN
   WRITE_LONG 0x001e 0x0001 //exclude chaotic
  END
  PATCH_IF (prohibited_alignment = 2) BEGIN
   WRITE_LONG 0x001e 0x0002 //exclude evil
  END
  PATCH_IF (prohibited_alignment = 3) BEGIN
   WRITE_LONG 0x001e 0x0004 //exclude good
  END
  PATCH_IF (prohibited_alignment = 4) BEGIN
   WRITE_LONG 0x001e 0x0020 //exclude ethical neutral
  END
  PATCH_IF (prohibited_alignment = 5) BEGIN
   WRITE_LONG 0x001e 0x0010 //exclude lawful
  END
  PATCH_IF (prohibited_alignment = 6) BEGIN
   WRITE_LONG 0x001e 0x0008 //exclude moral neutral
  END
END 


PATCH_IF (school >= 0) BEGIN
  PATCH_IF (school = 0) BEGIN
   WRITE_BYTE 0x0025 0x01 // None
  END
  PATCH_IF (school = 1) BEGIN
   WRITE_BYTE 0x0025 0x01 // Abjuration
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN //CHECK SPELLS: Wraithform, MMM, Fireshield
	REPLACE_TEXTUALLY ~Abjuration~ ~Abjuration~        //replacing old with new 
	REPLACE_TEXTUALLY ~Conjuration~ ~Abjuration~        //replacing old with new 
	REPLACE_TEXTUALLY ~Conjuration/Summoning~ ~Abjuration~        //replacing old with new 
	REPLACE_TEXTUALLY ~Alteration~ ~Abjuration~        //replacing old with new 
	REPLACE_TEXTUALLY ~Evocation~ ~Abjuration~        //replacing old with new 
	REPLACE_TEXTUALLY ~Necromancy~ ~Abjuration~        //replacing old with new 
	REPLACE_TEXTUALLY ~Enchantment/Charm~ ~Abjuration~        //replacing old with new 
	REPLACE_TEXTUALLY ~Illusion/Phantasm~ ~Abjuration~        //replacing old with new 
	REPLACE_TEXTUALLY ~(Divination)~ ~(Abjuration)~        //replacing old with new
	REPLACE_TEXTUALLY ~School: Divination~ ~School: Abjuration~        //replacing old with new
	END       //
  SAY_EVALUATED 0x50 ~%new_desc%~
  END  // end text change
  END
  PATCH_IF (school = 2) BEGIN
   WRITE_BYTE 0x0025 0x02 // Conjuration
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN //CHECK SPELLS: Wraithform, MMM, Fireshield
	REPLACE_TEXTUALLY ~Abjuration~ ~Conjuration~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration~ ~Conjuration~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration/Summoning~ ~Conjuration/Summoning~        //replacing old with new
	REPLACE_TEXTUALLY ~Alteration~ ~Conjuration~        //replacing old with new
	REPLACE_TEXTUALLY ~Evocation~ ~Conjuration~        //replacing old with new
	REPLACE_TEXTUALLY ~Necromancy~ ~Conjuration~        //replacing old with new
	REPLACE_TEXTUALLY ~Enchantment/Charm~ ~Conjuration~        //replacing old with new
	REPLACE_TEXTUALLY ~Illusion/Phantasm~ ~Conjuration~        //replacing old with new
	REPLACE_TEXTUALLY ~(Divination)~ ~(Conjuration)~        //replacing old with new
	REPLACE_TEXTUALLY ~School: Divination~ ~School: Conjuration~        //replacing old with new
	END
	//
  SAY_EVALUATED 0x50 ~%new_desc%~
  END  // end text change
  END
  PATCH_IF (school = 3) BEGIN
   WRITE_BYTE 0x0025 0x03 // (Divination)
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN //CHECK SPELLS: Wraithform, MMM, Fireshield
	REPLACE_TEXTUALLY ~Abjuration~ ~Divination~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration~ ~Divination~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration/Summoning~ ~Divination~        //replacing old with new
	REPLACE_TEXTUALLY ~Alteration~ ~Divination~        //replacing old with new
	REPLACE_TEXTUALLY ~Evocation~ ~Divination~        //replacing old with new
	REPLACE_TEXTUALLY ~Necromancy~ ~Divination~        //replacing old with new
	REPLACE_TEXTUALLY ~Enchantment/Charm~ ~Divination~        //replacing old with new
	REPLACE_TEXTUALLY ~Illusion/Phantasm~ ~Divination~        //replacing old with new
	END
	//
  SAY_EVALUATED 0x50 ~%new_desc%~
  END  // end text change
  END
  PATCH_IF (school = 4) BEGIN
   WRITE_BYTE 0x0025 0x04 // Enchanter
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN //CHECK SPELLS: Wraithform, MMM, Fireshield
	REPLACE_TEXTUALLY ~Abjuration~ ~Enchantment/Charm~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration~ ~Enchantment/Charm~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration/Summoning~ ~Enchantment/Charm~        //replacing old with new
	REPLACE_TEXTUALLY ~Alteration~ ~Enchantment/Charm~        //replacing old with new
	REPLACE_TEXTUALLY ~Evocation~ ~Enchantment/Charm~        //replacing old with new
	REPLACE_TEXTUALLY ~Necromancy~ ~Enchantment/Charm~        //replacing old with new
	REPLACE_TEXTUALLY ~Enchantment/Charm~ ~Enchantment/Charm~        //replacing old with new
	REPLACE_TEXTUALLY ~Illusion/Phantasm~ ~Enchantment/Charm~        //replacing old with new
	REPLACE_TEXTUALLY ~(Divination)~ ~(Enchantment/Charm)~        //replacing old with new
	REPLACE_TEXTUALLY ~School: Divination~ ~School: Enchantment/Charm~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~   //
  END  // end text change
  END
  PATCH_IF (school = 5) BEGIN
   WRITE_BYTE 0x0025 0x05 // Illusion
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN //CHECK SPELLS: Wraithform, MMM, Fireshield
	REPLACE_TEXTUALLY ~Abjuration~ ~Illusion/Phantasm~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration~ ~Illusion/Phantasm~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration/Summoning~ ~Illusion/Phantasm~        //replacing old with new
	REPLACE_TEXTUALLY ~Alteration~ ~Illusion/Phantasm~        //replacing old with new
	REPLACE_TEXTUALLY ~Evocation~ ~Illusion/Phantasm~        //replacing old with new
	REPLACE_TEXTUALLY ~Necromancy~ ~Illusion/Phantasm~        //replacing old with new
	REPLACE_TEXTUALLY ~Enchantment/Charm~ ~Illusion/Phantasm~        //replacing old with new
	REPLACE_TEXTUALLY ~Illusion/Phantasm~ ~Illusion/Phantasm~        //replacing old with new
	REPLACE_TEXTUALLY ~(Divination)~ ~(Illusion/Phantasm)~        //replacing old with new
	REPLACE_TEXTUALLY ~School: Divination~ ~School: Illusion/Phantasm~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~   //
  END  // end text change
  END
  PATCH_IF (school = 6) BEGIN
   WRITE_BYTE 0x0025 0x06 // Invoker
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN //CHECK SPELLS: Wraithform, MMM, Fireshield
	REPLACE_TEXTUALLY ~Abjuration~ ~Evocation~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration~ ~Evocation~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration/Summoning~ ~Evocation~        //replacing old with new
	REPLACE_TEXTUALLY ~Alteration~ ~Evocation~        //replacing old with new
	REPLACE_TEXTUALLY ~Evocation~ ~Evocation~        //replacing old with new
	REPLACE_TEXTUALLY ~Necromancy~ ~Evocation~        //replacing old with new
	REPLACE_TEXTUALLY ~Enchantment/Charm~ ~Evocation~        //replacing old with new
	REPLACE_TEXTUALLY ~Illusion/Phantasm~ ~Evocation~        //replacing old with new
	REPLACE_TEXTUALLY ~(Divination)~ ~(Evocation)~        //replacing old with new
	REPLACE_TEXTUALLY ~School: Divination~ ~School: Evocation~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~    //
  END  // end text change
  END
  PATCH_IF (school = 7) BEGIN
   WRITE_BYTE 0x0025 0x07 // Necro
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN //CHECK SPELLS: Wraithform, MMM, Fireshield
	REPLACE_TEXTUALLY ~Abjuration~ ~Necromancy~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration~ ~Necromancy~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration/Summoning~ ~Necromancy~        //replacing old with new
	REPLACE_TEXTUALLY ~Alteration~ ~Necromancy~        //replacing old with new
	REPLACE_TEXTUALLY ~Evocation~ ~Necromancy~        //replacing old with new
	REPLACE_TEXTUALLY ~Necromancy~ ~Necromancy~        //replacing old with new
	REPLACE_TEXTUALLY ~Enchantment/Charm~ ~Necromancy~        //replacing old with new
	REPLACE_TEXTUALLY ~Illusion/Phantasm~ ~Necromancy~        //replacing old with new
	REPLACE_TEXTUALLY ~(Divination)~ ~(Necromancy)~        //replacing old with new
	REPLACE_TEXTUALLY ~School: Divination~ ~School: Necromancy~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~      //
  END  // end text change
  END
  PATCH_IF (school = 8) BEGIN
   WRITE_BYTE 0x0025 0x08 // Transmutation
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN //CHECK SPELLS: Wraithform, MMM, Fireshield
	REPLACE_TEXTUALLY ~Abjuration~ ~Alteration~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration~ ~Alteration~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration/Summoning~ ~Alteration~        //replacing old with new
	REPLACE_TEXTUALLY ~Alteration~ ~Alteration~        //replacing old with new
	REPLACE_TEXTUALLY ~Evocation~ ~Alteration~        //replacing old with new
	REPLACE_TEXTUALLY ~Necromancy~ ~Alteration~        //replacing old with new
	REPLACE_TEXTUALLY ~Enchantment/Charm~ ~Alteration~        //replacing old with new
	REPLACE_TEXTUALLY ~Illusion/Phantasm~ ~Alteration~        //replacing old with new
	REPLACE_TEXTUALLY ~(Divination)~ ~(Alteration)~        //replacing old with new
	REPLACE_TEXTUALLY ~School: Divination~ ~School: Alteration~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~     //
  END  // end text change
  END
  PATCH_IF (school = 9) BEGIN
   WRITE_BYTE 0x0025 0x09 // Generalist(?)
  END
END

PATCH_IF (cleric_druid_only >= 0) BEGIN
  PATCH_IF (cleric_druid_only = 0) BEGIN
      READ_BYTE    0x21 none //
      WRITE_BYTE   0x21 (none BAND 0b00000000)  // reset
  END
  PATCH_IF (cleric_druid_only = 1) BEGIN
      READ_BYTE    0x21 none //
      WRITE_BYTE   0x21 (none BAND 0b00000000)  // reset
      READ_BYTE    0x21 cleric //
      WRITE_BYTE   0x21 (cleric BOR 0b10000000)  // set to cleric
  END
  PATCH_IF (cleric_druid_only = 2) BEGIN
      READ_BYTE    0x21 none //
      WRITE_BYTE   0x21 (none BAND 0b00000000)  // reset
      READ_BYTE    0x21 druid //
      WRITE_BYTE   0x21 (druid BOR 0b01000000)  // set to druid
  END
  PATCH_IF (cleric_druid_only = 3) BEGIN
      READ_BYTE    0x21 none //
      WRITE_BYTE   0x21 (none BAND 0b00000000)  // reset
      READ_BYTE    0x21 no_wild //
      WRITE_BYTE   0x21 (no_wild BOR 0b11000000)  // Restrict everybody
  END
END
//wild_mage if specified
PATCH_IF (wild_mage >= 0) BEGIN
  PATCH_IF (wild_mage = 0) BEGIN  //Wildmage Can't cast
      READ_BYTE    0x21 none //
      WRITE_BYTE   0x21 (none BAND 0b00000000)  // reset
      READ_BYTE    0x21 no_wild //
      WRITE_BYTE   0x21 (no_wild BOR 0b11000000)  // Restrict wildmage
  END
  PATCH_IF (wild_mage = 1) BEGIN //wildmage Can cast
      READ_BYTE    0x21 none //
      WRITE_BYTE   0x21 (none BAND 0b00000000)  // wildmage enabled
  END
END
//casting graphics if specified
PATCH_IF (casting_graphics >= 0) BEGIN
  PATCH_IF (casting_graphics = 0) BEGIN
   WRITE_SHORT 0x0022 00 // c.graphics -schooless
  END
  PATCH_IF (casting_graphics = 1) BEGIN
   WRITE_SHORT 0x0022 12 // c.graphics -abjuration
  END
  PATCH_IF (casting_graphics = 2) BEGIN
   WRITE_SHORT 0x0022 14 // c.graphics -conjuration
  END
  PATCH_IF (casting_graphics = 3) BEGIN
   WRITE_SHORT 0x0022 16 // c.graphics -divination
  END
  PATCH_IF (casting_graphics = 4) BEGIN
   WRITE_SHORT 0x0022 11 // c.graphics -enchantment
  END
  PATCH_IF (casting_graphics = 5) BEGIN
   WRITE_SHORT 0x0022 13 // c.graphics -illusion
  END
  PATCH_IF (casting_graphics = 6) BEGIN
   WRITE_SHORT 0x0022 15 // c.graphics -invoker
  END
  PATCH_IF (casting_graphics = 7) BEGIN
   WRITE_SHORT 0x0022 09 // c.graphics -necromancy
  END
  PATCH_IF (casting_graphics = 8) BEGIN
   WRITE_SHORT 0x0022 10 // c.graphics -alteration
  END
  PATCH_IF (casting_graphics = 9) BEGIN
   WRITE_SHORT 0x0022 18 // c.graphics -black sparks
  END
END
// Handle sec school if specified
PATCH_IF (sec_type >= 0) BEGIN
  PATCH_IF (sec_type = 0) BEGIN
   WRITE_LONG 0x0027 0x0000 //None
  END
  PATCH_IF (sec_type = 1) BEGIN
   WRITE_LONG 0x0027 0x01 //Spell Protection
  END
  PATCH_IF (sec_type = 2) BEGIN
   WRITE_LONG 0x0027 0x02 //-SPECIFICPROTECTIONS
  END
  PATCH_IF (sec_type = 3) BEGIN
   WRITE_LONG 0x0027 0x03 //-ILLUSIONARYPROTECTIONS
  END
  PATCH_IF (sec_type = 4) BEGIN
   WRITE_LONG 0x0027 0x04 //-MAGICATTACK
  END
  PATCH_IF (sec_type = 5) BEGIN
   WRITE_LONG 0x0027 0x05 //DIVINATIONATTACK
  END
  PATCH_IF (sec_type = 6) BEGIN
   WRITE_LONG 0x0027 0x06 //CONJURATION
  END
  PATCH_IF (sec_type = 7) BEGIN
   WRITE_LONG 0x0027 0x07 //0x07-COMBATPROTECTIONS
  END
  PATCH_IF (sec_type = 8) BEGIN
   WRITE_LONG 0x0027 0x08 //0x08-CONTINGENCY
  END
  PATCH_IF (sec_type = 9) BEGIN
   WRITE_LONG 0x0027 0x09 //0x09-BATTLEGROUND
  END
  PATCH_IF (sec_type = 10) BEGIN
   WRITE_LONG 0x0027 0x0a //-OFFENSIVEDAMAGE
  END
  PATCH_IF (sec_type = 11) BEGIN
   WRITE_LONG 0x0027 0x0b //0x0b-DISABLING
  END
  PATCH_IF (sec_type = 12) BEGIN
   WRITE_LONG 0x0027 0x0c //0x0c-COMBINATION
  END
  PATCH_IF (sec_type = 13) BEGIN
   WRITE_LONG 0x0027 0x0d //0x0d-NON-COMBAT
  END
  PATCH_IF (sec_type = 14) BEGIN
   WRITE_LONG 0x0027 0x0e //0x0e-DORNS_SWORD
  END
END

//Handle hostile if specified
PATCH_IF (hostile = 0) BEGIN
      READ_BYTE    0x19 no_hos //
      WRITE_BYTE   0x19 (no_hos BAND 0b11111011)  //
END
PATCH_IF (hostile = 1) BEGIN
      READ_BYTE    0x19 hos //
      WRITE_BYTE   0x19 (hos BOR 0b00000100)  //
END
// Handle failure if specified
PATCH_IF (failure = 0) BEGIN
   WRITE_LONG 0x0018 (THIS | 0x4000)       //No failure
END
PATCH_IF (failure = 1) BEGIN
      READ_BYTE    0x19 no_fail //
      WRITE_BYTE   0x19 (no_fail BAND 0b10111111)  // not no fail
END

// Handle indoors if specified
PATCH_IF (indoors = 0) BEGIN
   WRITE_LONG 0x0018 (THIS | 0x2000)       //Not indoors
END
PATCH_IF (indoors = 1) BEGIN
      READ_BYTE    0x19 inside //
      WRITE_BYTE   0x19 (inside BAND 0b11011111)  // Can be cast indoors
END

// Handle surge if specified
PATCH_IF (surge = 0) BEGIN
   WRITE_LONG 0x0018 (THIS | 0x8000)       //No wildsurge
END
PATCH_IF (surge = 1) BEGIN
      READ_BYTE    0x19 no_surge //
      WRITE_BYTE   0x19 (no_surge BAND 0b01111111)  // not no surge
END

// Handle spotting if specified
PATCH_IF (spotting = 0) BEGIN
      READ_BYTE    0x19 spot //
      WRITE_BYTE   0x19 (spot BAND 0b11101111)  // not spot
END
PATCH_IF (spotting = 1) BEGIN
   WRITE_LONG 0x0018 (THIS | 0x1000)       //allow spotting?
END

//Handle LOS if specified
PATCH_IF (los = 0) BEGIN
      READ_BYTE    0x19 see //
      WRITE_BYTE   0x19 (see BAND 0b11110111)  // LOS required
END
PATCH_IF (los = 1) BEGIN
      READ_BYTE    0x19 see //
      WRITE_BYTE   0x19 (see BOR 0b00001000)  //  los not required
END

// Handle combat if specified
PATCH_IF (combat = 0) BEGIN
    READ_BYTE     0x001a fail //reads the byte
    WRITE_BYTE    0x001a (fail BOR 0b00000001)  // CANNOT cast in combat
END 
PATCH_IF (combat = 1) BEGIN
    READ_BYTE     0x001a fail //reads the byte
    WRITE_BYTE    0x001a (fail BAND 0b11111110)  // CAN cast in combat
END
//target_invisible if specified
PATCH_IF (target_invisible = 0) BEGIN
    READ_BYTE     0x001b invis //reads the byte
    WRITE_BYTE    0x001b (invis BAND 0b11111110)  // CANNOT target invis
END
PATCH_IF (target_invisible = 1) BEGIN
    READ_BYTE     0x001b invis //reads the byte
    WRITE_BYTE    0x001b (invis BOR 0b00000001)  // CAN target invis
END

//silence if specified
PATCH_IF (silence = 0) BEGIN
    READ_BYTE     0x001b speak //reads the byte
    WRITE_BYTE    0x001b (speak BAND 0b11111101)  // CANNOT cast silenced
END
PATCH_IF (silence = 1) BEGIN
    READ_BYTE     0x001b speak //reads the byte
    WRITE_BYTE    0x001b (speak BOR 0b00000010)  // CAN cast silenced
END

//level text if specified
PATCH_IF ("%level_text%" STRING_COMPARE_CASE "SAME" != 0) BEGIN //
  
//lev x to lev y
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN
	REPLACE_TEXTUALLY ~Level: Cantrip~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: Orison~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 1~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 2~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 3~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 4~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 5~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 6~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 7~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 8~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 9~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: 10~ ~Level: %level_text%~        //replacing old with new 
	REPLACE_TEXTUALLY ~Level: Quest~ ~Level: %level_text%~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~
  END  // 

END //end lev text

//level school if specified
PATCH_IF ("%school_text%" STRING_COMPARE_CASE "SAME" != 0) BEGIN //
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN
	REPLACE_TEXTUALLY ~Abjuration~ ~%school_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration~ ~%school_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~Conjuration/Summoning~ ~%school_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~Alteration~ ~%school_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~Evocation~ ~%school_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~Necromancy~ ~%school_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~Enchantment/Charm~ ~%school_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~Illusion/Phantasm~ ~%school_text%~        //replacing old with new
	REPLACE_TEXTUALLY ~(Divination)~ ~(%school_text%)~        //replacing old with new
	REPLACE_TEXTUALLY ~School: Divination~ ~School: %school_text%~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~
  END  //
END//End school_text text

//level school if specified
PATCH_IF ("%sphere_text%" STRING_COMPARE_CASE "SAME" != 0) BEGIN //
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN
	  REPLACE_TEXTUALLY ~Sphere: Affliction~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Air~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: All~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Animal~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Animal, Summoning~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Benediction~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Chaos~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Charm~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Charm, Combat, Law~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Charm, Creation~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Charm, Law~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Charm, Protection~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Combat~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Combat, Necromantic~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Combat, Plant~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Combat, Summoning~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Creation~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Death~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Deception~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Destruction~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Divination~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Dread~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Earth~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental (Air)~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental Air~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental (Earth)~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental (Earth), Summoning~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental Earth~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental (Fire)~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental (Fire), Summoning~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental Fire~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental (Water)~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Elemental Water~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Exploration~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Fire~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Guardian~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Guardian, Creation~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Healing~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Knowledge~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Law~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Life~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Light~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Magic~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Necromantic~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Necromantic, Protection~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Numbers~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Perdition~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Plant~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Protection~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Protection, Elemental (Fire)~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Protection, Plant~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Protection, Sun~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Protection, Weather~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Shadow~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Summoning~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Sun~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Thought~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Travelers~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Universal~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Vigor~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: War~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Wards~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Wards, Elemental (Air)~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Water~ ~Sphere: %sphere_text%~        //replacing old with new
	  REPLACE_TEXTUALLY ~Sphere: Weather~ ~Sphere: %sphere_text%~        //replacing old with new
//missing sphere info
	  REPLACE_TEXTUALLY ~1
Range~ ~1
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~2
Range~ ~2
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~3
Range~ ~3
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~4
Range~ ~4
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~5
Range~ ~5
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~6
Range~ ~6
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~7
Range~ ~7
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~8
Range~ ~8
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~9
Range~ ~9
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~Quest
Range~ ~Quest
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~Orison
Range~ ~Orison
Sphere: %sphere_text%
Range~        //replacing old with new
	  REPLACE_TEXTUALLY ~Cantrip
Range~ ~Cantrip
Sphere: %sphere_text%
Range~        //replacing old with new
END
  SAY_EVALUATED 0x50 ~%new_desc%~
  END  //
END//End school_text text

//c_icon if specified
PATCH_IF ("%c_icon%" STRING_COMPARE_CASE "NO" != 0) BEGIN //
 PATCH_IF ("%c_icon%" STRING_COMPARE_CASE "SAME" = 0) BEGIN //
  WRITE_EVALUATED_ASCII 0x003a ~%SOURCE_RES%C~
 END  
 ELSE PATCH_IF ("%c_icon%" STRING_COMPARE_CASE "ADD" = 0) BEGIN
  WRITE_EVALUATED_ASCII 0x003a ~%spell_res%C~
 END
 ELSE
 BEGIN
  WRITE_EVALUATED_ASCII 0x003a ~%c_icon%~
 END
END//End c_icon

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////                    Item in Store                       //////////////////////////
//////////////////////////                   Credit: Camdawg                      //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION item_in_store
	STR_VAR item=""
	RET value
BEGIN
	value=0
	GET_OFFSET_ARRAY itm_arr STO_V10_ITEMS_SOLD
	PHP_EACH itm_arr AS itm_ind=>itm_off BEGIN
		PATCH_IF !value BEGIN
		READ_ASCII itm_off resref
			value = ("%resref%" STR_EQ "%item%")? 1: 0
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////                    Item in Store                       //////////////////////////
//////////////////////////                   Credit: Kjeron                       //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION TEXT_REPLACE
  STR_VAR   orig_text        = "SAME"  //Original Text to be replaced
   	    new_text	     = "SAME"  //New Text
BEGIN

//orig_text if specified
PATCH_IF ("%orig_text%" STRING_COMPARE_CASE "SAME" != 0) BEGIN //
  READ_LONG 0x50 "valid"
  PATCH_IF (%valid% >= 0) BEGIN // verify desc is valid
  READ_STRREF 0x50 ~desc~
	INNER_PATCH_SAVE new_desc ~%desc%~ BEGIN
	REPLACE_TEXTUALLY ~%orig_text%~ ~%new_text%~        //replacing old with new
	END
  SAY_EVALUATED 0x50 ~%new_desc%~
  END  // 

END //end lev text
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////                      Add Icons                         //////////////////////////
//////////////////////////                                                        //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ADD_ICONS
  INT_VAR   rename            = "0"       //rename icons based on spell_res?  0 = no; 1 = yes
            port_text         = "-1"      //strref of portrait for port icon (optional, but pretty nec for adding port icons)
            add_port_icon     = "0"       //Add port icon to spell (be careful) 0= no, 1= yes (all), 2= yes, but ONLY global
            create_scroll     = "0"       //create a scroll? 0 = no; 1 = yes (provide a path in STR_VAR scroll_path)
            gen_scroll        = "0"       //is the scroll provided in scroll_path generic (i.e. need to add deets?) 0 = no; 1 =yes
            high_hedge        = "0"       //place a scroll or two in hedge hedge (if present--bgee)
            high_hedge_no     = "1"       //Number of scrolls sold at High Hedge (default 1)
            pen_parch         = "0"       //place a scroll or two in Pen and Parchment  (if present--bg2ee)
            pen_parch_no      = "1"       //Number of scrolls sold at Pen and Parchment (default 1)
            under_merch       = "0"       //place a scroll or two in underdark merchant (if present--bg2ee)
            under_merch_no    = "1"       //Number of scrolls sold at underdark merchant (default 1)
            sor_sun           = "0"       //place a scroll or two in Sorcerous Sundries  (if present--bgee and maybe sod)
            sor_sun_no        = "1"       //Number of scrolls sold at Sorcerous Sundries (default 1)
            sod_store         = "0"       //place a scroll or two in ...some SOD store  (if present--maybe sod)
            sod_store_no      = "1"       //Number of scrolls sold at ...some SOD store (default 1)
//          scroll_store      = "0"       //add scroll to stores?  We'll see

  STR_VAR   pathA             = "SAME"    //path to "A" icon (req for scroll--otherwise optional)
            pathB             = "SAME"    //path to "B" icon (optional)
            pathC             = "SAME"    //path to "C" icon (optional)
            pathP             = "SAME"    //path to portrait icon (optional)
            port_exist        = "SAME"    //portrait icon if already in game(optional)
            scroll_path       = "SAME"    //path of scroll--will create a scroll if pathA AND this field not "SAME" (optional)
            spell_name        = "SAME"    //filename of spell that is getting the icons--assumes spell was added prior (required)
  RET       iconA                         //name of iconA
            iconB                         //name of iconB
            iconC                         //name of iconC
            iconP                         //name of portrait icon
            port_icon                     //Returns portrait icon line for removal/protection/ALTER_EFFECT, etc.
            scroll_name                   //Returns the name of the scroll
//          scroll_icon                   //Returns "A" icon for scrolls--needed?

BEGIN

 ACTION_IF ("%spell_name%" STRING_COMPARE_CASE "SAME" != 0) BEGIN //

//add icon A
   ACTION_IF ("%pathA%" STRING_COMPARE_CASE "SAME" != 0) BEGIN    //
     ACTION_IF (rename > 0)  BEGIN
      COPY ~%pathA%~ ~override/%spell_name%A.BAM~
       COPY_EXISTING ~%spell_name%A.BAM~ ~override~
        INNER_PATCH_SAVE iconA ~%SOURCE_RES%~ BEGIN END //icon a named %iconA%
     END //end icon bams ~same name as spl
     ACTION_IF (rename = 0)  BEGIN
      COPY ~%pathA%~ ~override~
        INNER_PATCH_SAVE iconA ~%SOURCE_RES%~ BEGIN END //icon a named %iconA%
     END //end icon bams ~not same name as spl
   END //end actual pathA
//if no A
   ACTION_IF ("%pathA%" STRING_COMPARE_CASE "SAME" = 0) BEGIN    //
        OUTER_SPRINT ~iconA~ ~nil~ //icon a named %iconA%
   END //if no A
//add icon B
   ACTION_IF ("%pathB%" STRING_COMPARE_CASE "SAME" != 0) BEGIN    //
     ACTION_IF (rename > 0)  BEGIN
      COPY ~%pathB%~ ~override/%spell_name%B.BAM~
       COPY_EXISTING ~%spell_name%B.BAM~ ~override~
        INNER_PATCH_SAVE iconB ~%SOURCE_RES%~ BEGIN END //icon a named %iconB%
     END //end icon bams ~same name as spl
     ACTION_IF (rename = 0)  BEGIN
      COPY ~%pathB%~ ~override~
        INNER_PATCH_SAVE iconB ~%SOURCE_RES%~ BEGIN END //icon a named %iconB%
     END //end icon bams ~not same name as spl
   END //end actual pathB
//if no B
   ACTION_IF ("%pathB%" STRING_COMPARE_CASE "SAME" = 0) BEGIN    //
        OUTER_SPRINT ~iconB~ ~nil~ //icon a named %iconB%
   END //if no B

//add icon C
   ACTION_IF ("%pathC%" STRING_COMPARE_CASE "SAME" != 0) BEGIN    //
     ACTION_IF (rename > 0)  BEGIN
      COPY ~%pathC%~ ~override/%spell_name%C.BAM~
       COPY_EXISTING ~%spell_name%C.BAM~ ~override~
        INNER_PATCH_SAVE iconC ~%SOURCE_RES%~ BEGIN END //icon a named %iconC%
     END //end icon bams ~same name as spl
     ACTION_IF (rename = 0)  BEGIN
      COPY ~%pathC%~ ~override~
        INNER_PATCH_SAVE iconC ~%SOURCE_RES%~ BEGIN END //icon a named %iconC%
     END //end icon bams ~not same name as spl
   END //end actual pathC
//if no C
   ACTION_IF ("%pathC%" STRING_COMPARE_CASE "SAME" = 0) BEGIN    //
        OUTER_SPRINT ~iconC~ ~nil~ //icon a named %iconA%
   END //if no C
//Portrait icon
   ACTION_IF ("%pathP%" STRING_COMPARE_CASE "SAME" != 0) BEGIN    //
      COPY ~%pathP%~ ~override~
       SET strref = %port_text% //
        INNER_PATCH_SAVE iconP ~%SOURCE_RES%~ BEGIN END //icon a named %iconP%

//Add icon to STATEDEC.2da (Thanks kjeron and argent77!!!)
 COPY_EXISTING ~STATDESC.2DA~ ~override~
  COUNT_2DA_COLS cols
  COUNT_2DA_ROWS cols rows
  SET max = 0
  FOR (i = 0; i < rows; ++i) BEGIN
   READ_2DA_ENTRY i 0 cols num
   PATCH_IF num > max BEGIN max = num END
  END
SET max += 1
INSERT_2DA_ROW rows cols ~%max%   %strref%   %iconP%~
PRETTY_PRINT_2DA
        OUTER_SPRINT ~port_icon~ ~%max%~ //line # for icon

   END //end add portrait icon path
   ACTION_IF ("%port_exist%" STRING_COMPARE_CASE "SAME" != 0) BEGIN    // portrait is in game (pathP sould be default!)
        COPY_EXISTING ~%port_exist%.BAM~ override
            SET strref = %port_text% //
               INNER_PATCH_SAVE iconP ~%SOURCE_RES%~ BEGIN END //icon a named %iconP%
//Add icon to STATEDEC.2da (Thanks kjeron and argent77!!!)
 COPY_EXISTING ~STATDESC.2DA~ override
  COUNT_2DA_COLS cols
  COUNT_2DA_ROWS cols rows
  SET max = 0
  FOR (i = 0; i < rows; ++i) BEGIN
   READ_2DA_ENTRY i 0 cols num
   PATCH_IF num > max BEGIN max = num END
  END
SET max += 1
INSERT_2DA_ROW rows cols ~%max%   %strref%   %iconP%~
PRETTY_PRINT_2DA
        OUTER_SPRINT ~port_icon~ ~%max%~ //line # for icon
   END //end port icon in game

//if no P
   ACTION_IF ("%pathP%" STRING_COMPARE_CASE "SAME" = 0) AND ("%port_exist%" STRING_COMPARE_CASE "SAME" = 0) BEGIN    //
        OUTER_SPRINT ~iconP~ ~nil~ //icon a named %iconP%
        OUTER_SPRINT ~port_icon~ ~nil~ //line # for icon
   END //if no A


//now, add stuff to spell
//B
   ACTION_IF ("%pathB%" STRING_COMPARE_CASE "SAME" != 0) BEGIN    //
      COPY_EXISTING ~%spell_name%.spl~ ~override~
        LPF ALTER_SPELL_HEADER INT_VAR STR_VAR icon = EVAL  ~%iconB%~ END
   END //path B
//Now C
   ACTION_IF ("%pathC%" STRING_COMPARE_CASE "SAME" != 0) BEGIN    //
      COPY_EXISTING ~%spell_name%.spl~ ~override~
          WRITE_EVALUATED_ASCII 0x003a ~%iconC%~
   END
//add port icon?????? 
     ACTION_IF (add_port_icon > 0)  BEGIN
           ACTION_IF (add_port_icon = 1)  BEGIN   //add port icon to all
              COPY_EXISTING ~%spell_name%.spl~ ~override~
                 LPF ALTER_EFFECT INT_VAR match_opcode = 142 parameter2 = %max% END
           END
           ACTION_IF (add_port_icon = 2)  BEGIN   //add port icon Global ONLY
              COPY_EXISTING ~%spell_name%.spl~ ~override~
                 LPF ALTER_EFFECT INT_VAR match_opcode = 142 check_headers = 0 parameter2 = %max% END
           END
     END
//scroll stuff
   ACTION_IF (create_scroll > 0)  BEGIN
     ACTION_IF ("%scroll_path%" STRING_COMPARE_CASE "SAME" != 0) BEGIN    //
        //first copy over spell and get name and description infos (and let's do this for everything exept cost for non-generic)
        COPY_EXISTING ~%spell_name%.SPL~ ~override~
 	     READ_LONG  0x0034 level //spell level
             READ_LONG  0x0008 name //spell name
	     READ_LONG  0x0050 desc //description
	     READ_SHORT 0x007E target //Target-check
	     READ_SHORT 0x0080 range //range-check
        ACTION_IF (gen_scroll > 0)  BEGIN  //generic scroll
           COPY ~%scroll_path%~ ~override/%spell_name%S.ITM~   //hopefully that won't copy over any genuine spell items
             WRITE_LONG 0x0008 ~%name%~
             WRITE_LONG 0x000c ~%name%~
             WRITE_LONG 0x0054 ~%desc%~
             WRITE_SHORT 0x007E target //Target-check
             WRITE_SHORT 0x0080 range //range-check
             WRITE_LONG 0x0034 (level * 50)
             WRITE_EVALUATED_ASCII 0x003a ~%iconA%~
             LPF ALTER_ITEM_HEADER STR_VAR icon = EVAL  ~%iconA%~ END
             LPF ALTER_ITEM_EFFECT INT_VAR check_headers = 1 match_opcode = 146 STR_VAR resource = EVAL  ~%spell_name%~ END
             LPF ALTER_ITEM_EFFECT INT_VAR check_headers = 1 match_opcode = 147 STR_VAR resource = EVAL  ~%spell_name%~ END
             //now get scroll filename
              COPY_EXISTING ~%spell_name%S.ITM~ ~override~
                INNER_PATCH_SAVE scroll_name ~%SOURCE_RES%~ BEGIN END //name of scroll file
        END //end generic scroll creation
        ACTION_IF (gen_scroll = 0)  BEGIN  //non-generic scroll
           COPY ~%scroll_path%~ ~override/%spell_name%S.ITM~   //hopefully that won't copy over any genuine spell items
             WRITE_LONG 0x0008 ~%name%~
             WRITE_LONG 0x000c ~%name%~
             WRITE_LONG 0x0054 ~%desc%~
             WRITE_SHORT 0x007E target //Target-check
             WRITE_SHORT 0x0080 range //range-check
             WRITE_EVALUATED_ASCII 0x003a ~%iconA%~
             LPF ALTER_ITEM_HEADER STR_VAR icon = EVAL  ~%iconA%~ END
             LPF ALTER_ITEM_EFFECT INT_VAR check_headers = 1 match_opcode = 146 STR_VAR resource = EVAL  ~%spell_name%~ END
             LPF ALTER_ITEM_EFFECT INT_VAR check_headers = 1 match_opcode = 147 STR_VAR resource = EVAL  ~%spell_name%~ END
             //now get scroll filename
              COPY_EXISTING ~%spell_name%S.ITM~ ~override~
                INNER_PATCH_SAVE scroll_name ~%SOURCE_RES%~ BEGIN END //name of scroll file
        END  //nongeneric scroll creation
//place scroll

//high hedge
   ACTION_IF (high_hedge > 0)  BEGIN
    COPY ~%mod_folder%/lib/scroll_stores/high_hedge.tpa~ ~%mod_folder%/lib/scroll_stores/high_hedge.tpa~
      REPLACE_TEXTUALLY ~NUM~ ~%high_hedge_no%~
             ACTION_IF FILE_EXISTS_IN_GAME ~HIGHHEDG.STO~ BEGIN  //
                  INCLUDE ~%mod_folder%/lib/scroll_stores/high_hedge.tpa~
             END
    COPY ~%mod_folder%/lib/scroll_stores/high_hedge.tpa~ ~%mod_folder%/lib/scroll_stores/high_hedge.tpa~
      REPLACE_TEXTUALLY ~%high_hedge_no%~ ~NUM~
   END
//Pen and Parchment
  ACTION_IF (pen_parch > 0)  BEGIN
    COPY ~%mod_folder%/lib/scroll_stores/pen.tpa~ ~%mod_folder%/lib/scroll_stores/pen.tpa~
      REPLACE_TEXTUALLY ~NUM~ ~%pen_parch_no%~
             ACTION_IF FILE_EXISTS_IN_GAME ~SCROLLS.STO~ BEGIN  //
                  INCLUDE ~%mod_folder%/lib/scroll_stores/pen.tpa~
             END
    COPY ~%mod_folder%/lib/scroll_stores/pen.tpa~ ~%mod_folder%/lib/scroll_stores/pen.tpa~
      REPLACE_TEXTUALLY ~%pen_parch_no%~ ~NUM~
  END

//Underdark Merchant
   ACTION_IF (under_merch > 0)  BEGIN
    COPY ~%mod_folder%/lib/scroll_stores/under_merch.tpa~ ~%mod_folder%/lib/scroll_stores/under_merch.tpa~
      REPLACE_TEXTUALLY ~NUM~ ~%under_merch_no%~
             ACTION_IF FILE_EXISTS_IN_GAME ~UDDROW25.STO~ BEGIN  //
                  INCLUDE ~%mod_folder%/lib/scroll_stores/under_merch.tpa~
             END
    COPY ~%mod_folder%/lib/scroll_stores/under_merch.tpa~ ~%mod_folder%/lib/scroll_stores/under_merch.tpa~
      REPLACE_TEXTUALLY ~%pen_parch_no%~ ~NUM~
   END
//Sorcerous Sundries
   ACTION_IF (sor_sun > 0)  BEGIN
    COPY ~%mod_folder%/lib/scroll_stores/sor_sun.tpa~ ~%mod_folder%/lib/scroll_stores/sor_sun.tpa~
      REPLACE_TEXTUALLY ~NUM~ ~%sor_sun_no%~
             ACTION_IF FILE_EXISTS_IN_GAME ~STO0703.STO~ BEGIN  //
                  INCLUDE ~%mod_folder%/lib/scroll_stores/sor_sun.tpa~
             END
    COPY ~%mod_folder%/lib/scroll_stores/sor_sun.tpa~ ~%mod_folder%/lib/scroll_stores/sor_sun.tpa~
      REPLACE_TEXTUALLY ~%sor_sun_no%~ ~NUM~
   END
//SOD Store?
   ACTION_IF (sod_store > 0)  BEGIN
    COPY ~%mod_folder%/lib/scroll_stores/sod_store.tpa~ ~%mod_folder%/lib/scroll_stores/sod_store.tpa~
      REPLACE_TEXTUALLY ~NUM~ ~%sod_store_no%~
             ACTION_IF FILE_EXISTS_IN_GAME ~BDSORCSC.STO~ BEGIN  //
                  INCLUDE ~%mod_folder%/lib/scroll_stores/sor_sun.tpa~
             END
    COPY ~%mod_folder%/lib/scroll_stores/sod_store.tpa~ ~%mod_folder%/lib/scroll_stores/sod_store.tpa~
      REPLACE_TEXTUALLY ~%sod_store_no%~ ~NUM~
   END
//add more stores CONTINUE

     END //scroll path non blank
//scroll creation fail
     ACTION_IF ("%scroll_path%" STRING_COMPARE_CASE "SAME" = 0) BEGIN    //
 		FAIL @1039  //You must specify a scroll path in order to create a scroll
     END
   END//end create scroll
   ACTION_IF (create_scroll = 0)  BEGIN   
   //just need to fill the variable
        OUTER_SPRINT ~scroll_name~ ~nil~ //file named %scroll_name%
   END
 END//end required spell_name
 ELSE BEGIN
 		FAIL @1011  //You must specify a spell file name for this function to work
 END //end fail
END //end function

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////             Add second opposition school               //////////////////////////
//////////////////////////                                                        //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION SECOND_OPP
  INT_VAR   generalist        = "-1" //1 = Prohibit Generalist (too)(NO OTHER VALUES ACCEPTED) TEST
            abjuration        = "-1" //1 = Prohibit Abjuration (too)(NO OTHER VALUES ACCEPTED) TEST
            conjuration       = "-1" //1 = Prohibit Conjuration (too)(NO OTHER VALUES ACCEPTED) TEST
            divination        = "-1" //1 = Prohibit Divination (too)(NO OTHER VALUES ACCEPTED) TEST
            enchantment       = "-1" //1 = Prohibit Enchantment (too)(NO OTHER VALUES ACCEPTED) TEST
            illusionist       = "-1" //1 = Prohibit Illusion (too)(NO OTHER VALUES ACCEPTED) TEST
            invocation        = "-1" //1 = Prohibit Invocation (too)(NO OTHER VALUES ACCEPTED) TEST
            necromancy        = "-1" //1 = Prohibit Necromancy (too)(NO OTHER VALUES ACCEPTED) TEST
            alteration        = "-1" //1 = Prohibit Transmutation (too)(NO OTHER VALUES ACCEPTED) TEST
            chaos             = "-1" //1 = Prohibit Chaotic priests (too)(NO OTHER VALUES ACCEPTED) TEST
            evil              = "-1" //1 = Prohibit Evil priests (too)(NO OTHER VALUES ACCEPTED) TEST
            good              = "-1" //1 = Prohibit Good priests (too)(NO OTHER VALUES ACCEPTED) TEST
            geneutral         = "-1" //1 = Prohibit moral neutral priests (too)(NO OTHER VALUES ACCEPTED) TEST
            law               = "-1" //1 = Prohibit Lawful priests (too)(NO OTHER VALUES ACCEPTED) TEST
            lcneutral         = "-1" //1 = Prohibit Morally neutral priests (too)(NO OTHER VALUES ACCEPTED) TEST
  STR_VAR   

  BEGIN

//Additional restricted schools if specified
PATCH_IF (generalist = 1) BEGIN //Adds Generalist restriction to spell
    READ_BYTE     0x001f general //reads the byte
    WRITE_BYTE    0x001f (general BOR 0b01000000)  //
END
PATCH_IF (abjuration = 1) BEGIN //Adds abjuration restriction to spell
    READ_BYTE     0x001e abj //reads the byte
    WRITE_BYTE    0x001e (abj BOR 0b01000000)  //
END
PATCH_IF (conjuration = 1) BEGIN //Adds conjuration restriction to spell
    READ_BYTE     0x001e conj //reads the byte
    WRITE_BYTE    0x001e (conj BOR 0b10000000)  //
END
PATCH_IF (divination = 1) BEGIN //Adds divination restriction to spell
    READ_BYTE     0x001f div //reads the byte
    WRITE_BYTE    0x001f (div BOR 0b00000001)  //
END
PATCH_IF (enchantment = 1) BEGIN //Adds enchantment restriction to spell
    READ_BYTE     0x001f enc //reads the byte
    WRITE_BYTE    0x001f (enc BOR 0b00000010)  //
END
PATCH_IF (illusionist = 1) BEGIN //Adds illusionist restriction to spell
    READ_BYTE     0x001f enc //reads the byte
    WRITE_BYTE    0x001f (enc BOR 0b00000100)  //
END
PATCH_IF (invocation = 1) BEGIN //Adds invocation restriction to spell
    READ_BYTE     0x001f inv //reads the byte
    WRITE_BYTE    0x001f (inv BOR 0b00001000)  //
END
PATCH_IF (necromancy = 1) BEGIN //Adds necromancy restriction to spell
    READ_BYTE     0x001f nec //reads the byte
    WRITE_BYTE    0x001f (nec BOR 0b00010000)  //
END
PATCH_IF (alteration = 1) BEGIN //Adds alteration restriction to spell
    READ_BYTE     0x001f alt //reads the byte
    WRITE_BYTE    0x001f (alt BOR 0b00100000)  //
END
PATCH_IF (chaos = 1) BEGIN //Adds chaos restriction to spell
    READ_BYTE     0x001e cha //reads the byte
    WRITE_BYTE    0x001e (cha BOR 0b00000001)  //
END
PATCH_IF (evil = 1) BEGIN //Adds evil restriction to spell
    READ_BYTE     0x001e evi //reads the byte
    WRITE_BYTE    0x001e (evi BOR 0b00000010)  //
END
PATCH_IF (good = 1) BEGIN //Adds good restriction to spell
    READ_BYTE     0x001e god //reads the byte
    WRITE_BYTE    0x001e (god BOR 0b00000100)  //
END
PATCH_IF (geneutral = 1) BEGIN //Adds neutral moral restriction to spell
    READ_BYTE     0x001e nmor //reads the byte
    WRITE_BYTE    0x001e (nmor BOR 0b00001000)  //
END
PATCH_IF (law = 1) BEGIN //Adds law restriction to spell
    READ_BYTE     0x001e lw //reads the byte
    WRITE_BYTE    0x001e (lw BOR 0b00010000)  //
END
PATCH_IF (lcneutral = 1) BEGIN //Adds neutral ethical restriction to spell
    READ_BYTE     0x001e neth //reads the byte
    WRITE_BYTE    0x001e (neth BOR 0b00100000)  //
END

  END
  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////                                                        //////////////////////////
//////////////////////////                   Misc. HLA stuff                      //////////////////////////
//////////////////////////                                                        //////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////
//   Created by morpheus562 and subtledoctor and shamelessly merged by grammarsalad  //
///////////////////////////////////////////////////////////////////////////////////////
DEFINE_ACTION_FUNCTION DESTRUCTO_REMOVE_HLA
  INT_VAR
    class = 2       // Class ID to add HLAs to
    min_lev = 1     // Min Lev to receive HLA
    max_lev = 99    // Max Level to receive HLA
    num_allowed = 1 // Number of times the ability can be taken
  STR_VAR
    ability = ""       // New ability being added 
    prerequisite = "*" // Ability is required first
    excluded_by = "*"  // Excluded by field
    alignment = "*"    // Alignment requirements
    remove_ability = ~*~  //ability to be removed
  BEGIN

  // Find class in class.ids
  COPY_EXISTING ~CLASS.IDS~ ~override~
  COUNT_2DA_ROWS 2 rows
  PATCH_IF (%class% > 0) AND (%class% < rows) BEGIN
    READ_2DA_ENTRY class 1 2 class_name
  END ELSE BEGIN
    PATCH_PRINT ~The selected class number, %class%, is out of bounds.~
  END

  // Find class in luabbr.2da
  COPY_EXISTING ~LUABBR.2DA~ ~override~
  COUNT_2DA_ROWS 2 rows
  FOR (index = 1; index < rows; ++index) BEGIN
    READ_2DA_ENTRY index 0 2 row_name
    PATCH_IF ~%row_name%~ STRING_EQUAL_CASE ~%class_name%~ BEGIN
      READ_2DA_ENTRY index 1 2 classlu
    END
  END

  // remove the new HLA from the correct class luxxx.2da file
  ACTION_IF FILE_EXISTS_IN_GAME ~lu%classlu%.2da~ BEGIN
    COPY_EXISTING ~lu%classlu%.2da~ ~override~
      COUNT_2DA_COLS cols // amount of columns
      COUNT_2DA_ROWS cols rows // amount of rows
          READ_2DA_ENTRIES_NOW file cols // read all file into memory
          SET num_deleted = 0
          FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
            READ_2DA_ENTRY_FORMER file i 1 col_value // read column value
            PATCH_IF (~%col_value%~ STRING_EQUAL_CASE ~%remove_ability%~) BEGIN // match .spl to be removed
              REMOVE_2DA_ROW (i - num_deleted) cols // kill the row
              SET num_deleted += 1
            END
          END
       PRETTY_PRINT_2DA
    BUT_ONLY
  END

  // REMOVE HLAS From KITS -----------------------------------------------------//
  // Find kits in kitlist
  COPY_EXISTING ~KITLIST.2DA~ ~override~
  READ_2DA_ENTRIES_NOW ~kits~ 10
  FOR (row = 3; row < kits; row += 1) BEGIN
  READ_2DA_ENTRY_FORMER ~kits~ row 5 kit_clab
  READ_2DA_ENTRY_FORMER ~kits~ row 1 kit_label
  READ_2DA_ENTRY_FORMER ~kits~ row 8 kit_class

  PATCH_IF (%kit_class% = %class%) BEGIN
    // Add HLAs to all Class Kits
    INNER_ACTION BEGIN
    COPY_EXISTING ~LUABBR.2DA~ ~override~
    COUNT_2DA_ROWS 2 rows
    FOR (index = 1; index < rows; ++index) BEGIN
      READ_2DA_ENTRY index 0 2 row_name
      PATCH_IF ~%row_name%~ STRING_EQUAL_CASE ~%kit_label%~ BEGIN
        READ_2DA_ENTRY index 1 2 kitlu
        PATCH_IF FILE_EXISTS_IN_GAME ~lu%kitlu%.2da~ BEGIN
          INNER_ACTION BEGIN
          COPY_EXISTING ~lu%kitlu%.2da~ ~override~
          COUNT_2DA_COLS cols // amount of columns
          COUNT_2DA_ROWS cols rows // amount of rows
          READ_2DA_ENTRIES_NOW file cols // read all file into memory
          SET num_deleted = 0
          FOR (i = 0; i < file; ++i) BEGIN // iterate over rows
              READ_2DA_ENTRY_FORMER file i 1 col_value // read column value
                  PATCH_IF (~%col_value%~ STRING_EQUAL_CASE ~%remove_ability%~) BEGIN // match .spl to be removed
                    REMOVE_2DA_ROW (i - num_deleted) cols // kill the row
                    SET num_deleted += 1
                  END
          END
          PRETTY_PRINT_2DA
          END
        END
      END
    END
    END
  END
  END
END




///////////////////////////////////////////////////////////////////////////////////////
//  Created by morpheus562 and Subtledoctor and shamelessly altered by grammarsalad  //
///////////////////////////////////////////////////////////////////////////////////////
DEFINE_ACTION_FUNCTION SIMPLE_REPLACE_HLA
  INT_VAR
    class = 2       // Class ID to add HLAs to
    min_lev = 1     // Min Lev to receive HLA
    max_lev = 99    // Max Level to receive HLA
    num_allowed = 1 // Number of times the ability can be taken
  STR_VAR
    ability = ""       // New ability being added
    remove_ability = ~*~
    2da_row = ~1~
    icon = ~*~
    strref = ~*~
    min_lev = ~1~
    max_level = ~99~
    num_allowed = ~1~
    prerequisite = ~*~
    excluded_by = ~*~
    alignment_restrict = ~*~
  BEGIN

  // Find class in class.ids
  COPY_EXISTING ~CLASS.IDS~ ~override~
  COUNT_2DA_ROWS 2 rows
  PATCH_IF (%class% > 0) AND (%class% < rows) BEGIN
    READ_2DA_ENTRY class 1 2 class_name
  END ELSE BEGIN
    PATCH_PRINT ~The selected class number, %class%, is out of bounds.~
  END

  // Find class in luabbr.2da
  COPY_EXISTING ~LUABBR.2DA~ ~override~
  COUNT_2DA_ROWS 2 rows
  FOR (index = 1; index < rows; ++index) BEGIN
    READ_2DA_ENTRY index 0 2 row_name
    PATCH_IF ~%row_name%~ STRING_EQUAL_CASE ~%class_name%~ BEGIN
      READ_2DA_ENTRY index 1 2 classlu
    END
  END

  // remove the new HLA from the correct class luxxx.2da file
  ACTION_IF FILE_EXISTS_IN_GAME ~lu%classlu%.2da~ BEGIN
    COPY_EXISTING ~lu%classlu%.2da~ ~override~
         LPF patch_replace_hla STR_VAR remove_ability = EVAL ~%remove_ability%~
                                       ability = EVAL ~%ability%~
                                       num_allowed = EVAL ~%num_allowed%~
                                       2da_row = EVAL ~%2da_row%~
                                       icon = EVAL ~%icon%~
                                       strref = EVAL ~%strref%~
                                       min_lev = EVAL ~%min_lev%~
                                       max_level = EVAL ~%max_level%~
                                       prerequisite = EVAL ~%prerequisite%~
                                       excluded_by = EVAL ~%excluded_by%~
                                       alignment_restrict = EVAL ~%alignment_restrict%~
         END
       PRETTY_PRINT_2DA
    BUT_ONLY
  END

  // REMOVE HLAS From KITS -----------------------------------------------------//
  // Find kits in kitlist
  COPY_EXISTING ~KITLIST.2DA~ ~override~
  READ_2DA_ENTRIES_NOW ~kits~ 10
  FOR (row = 3; row < kits; row += 1) BEGIN
  READ_2DA_ENTRY_FORMER ~kits~ row 5 kit_clab
  READ_2DA_ENTRY_FORMER ~kits~ row 1 kit_label
  READ_2DA_ENTRY_FORMER ~kits~ row 8 kit_class

  PATCH_IF (%kit_class% = %class%) BEGIN
    // Add HLAs to all Class Kits
    INNER_ACTION BEGIN
    COPY_EXISTING ~LUABBR.2DA~ ~override~
    COUNT_2DA_ROWS 2 rows
    FOR (index = 1; index < rows; ++index) BEGIN
      READ_2DA_ENTRY index 0 2 row_name
      PATCH_IF ~%row_name%~ STRING_EQUAL_CASE ~%kit_label%~ BEGIN
        READ_2DA_ENTRY index 1 2 kitlu
        PATCH_IF FILE_EXISTS_IN_GAME ~lu%kitlu%.2da~ BEGIN
          INNER_ACTION BEGIN
          COPY_EXISTING ~lu%kitlu%.2da~ ~override~
         LPF patch_replace_hla STR_VAR remove_ability = EVAL ~%remove_ability%~
                                       ability = EVAL ~%ability%~
                                       num_allowed = EVAL ~%num_allowed%~
                                       2da_row = EVAL ~%2da_row%~
                                       icon = EVAL ~%icon%~
                                       strref = EVAL ~%strref%~
                                       min_lev = EVAL ~%min_lev%~
                                       max_level = EVAL ~%max_level%~
                                       prerequisite = EVAL ~%prerequisite%~
                                       excluded_by = EVAL ~%excluded_by%~
                                       alignment_restrict = EVAL ~%alignment_restrict%~
         END
          PRETTY_PRINT_2DA
          BUT_ONLY
          END
        END
      END
    END
    END
  END
  END
END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
